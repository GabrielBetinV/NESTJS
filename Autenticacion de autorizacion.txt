** Crear la entidad de usuario


- Crear un nuevo recurso

nest g res auth --no-spec


- Creamos la entidad

import { Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  email: string;

  pasword: string;

  fullName: string;

  isActive: boolean;

  roles: string[];
}

- Importamos la entidad en el modulo para que se cree la tabla

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { User } from './entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';


@Module({
  controllers: [AuthController],
  providers: [AuthService],
  imports:[
    TypeOrmModule.forFeature([User])
  ],
  exports:[
    TypeOrmModule
  ]
})
export class AuthModule {}


- Terminamos de configurar las demas columnas de la entidad

import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text', {
    unique: true,
  })
  email: string;

  @Column('text')
  password: string;

  @Column('text')
  fullName: string;

  @Column('bool', {
    default: true,
  })
  isActive: boolean;

  @Column('text', {
    array: true,
    default: ['user'],
  })
  roles: string[];
}



** Crear usuario

- Crear el DTO para el usuario

create-user.dto.ts



Expression regular para la contraseña
https://gist.github.com/Klerith/c77edd9d86174aa68efbfddd21f053a2


import {
  IsEmail,
  IsString,
  Matches,
  MaxLength,
  MinLength,
} from 'class-validator';

export class CreateUserDto {
  @IsString()
  @IsEmail()
  email: string;

  // Agregar expresion regular para la contraseña
  @IsString()
  @MinLength(6)
  @MaxLength(50)
  @Matches(/(?:(?=.*\d)|(?=.*\W+))(?![.\n])(?=.*[A-Z])(?=.*[a-z]).*$/, {
    message:
      'The password must have a Uppercase, lowercase letter and a number',
  })
  password: string;

  @IsString()
  @MinLength(1)
  fullName: string;
}



- Importamos el DTO en el controlador para crear el usuario

import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto } from './dto/create-user.dto';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  create(@Body() createAuthDto: CreateUserDto) {
    return this.authService.create(createAuthDto);
  }
}


- Agregamos la funcion en el servicio

import { Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';


@Injectable()
export class AuthService {
  create(createAuthDto: CreateUserDto) {
    return 'This action adds a new auth';
  }

 
}


Probar en Insomnia, sin body para identificar que si esta validando el dto y con
body para ver que se ejecuta la funcion

{
	"email":"gbetin@music.com",
	"password": "Abc123",
	"fullName": "Gabriel Betin"
}


- Vamos a crear el usuario desde el servicio y creamos la funcion para el error

import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { InjectRepository } from '@nestjs/typeorm';

@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  async create(createAuthDto: CreateUserDto) {
    try {
      const user = this.userRepository.create(createAuthDto);
      await this.userRepository.save(user);
      return user;
    } catch (error) {
      this.handleDBErrors(error);
    }
  }

  private handleDBErrors(error: any) {
    if (error.code === '23505') throw new BadRequestException(error.detail);

    console.log(error);

    throw new InternalServerErrorException('Please check server logs');
  }
}


** Modulos Asyncronos

- Importamos el modulo de JWT de forma asyncrona en el auth module


    // Modulo asyncrono
    JwtModule.registerAsync({
      imports:[],
      inject:[],
      useFactory: () => {
        console.log('JWT_SECRET =>',  process.env.JWT_SECRET)

        return {
          secret: process.env.JWT_SECRET,
          signOptions:{
            expiresIn: '2h'
          }
        }
      }

    })

- De esta manera tambien se puede agregar el modulo, con el configservice

    // Modulo asyncrono agregando el ConfigService para obtener la variable de entorno
    JwtModule.registerAsync({
      imports:[ConfigModule],
      inject:[ConfigService],
      useFactory: (configService: ConfigService) => {
        console.log('JWT_SECRET =>',  configService.get('JWT_SECRET') )

        return {
          secret: configService.get('JWT_SECRET') ,
          signOptions:{
            expiresIn: '2h'
          }
        }
      }

    })

De esta manera ya tenemos la firma que va a tener nuestrosd JWT

** JwtStrategy

https://jwt.io/

- Crear una carpeta llamada strategies dentro de auth

- Crear la interface que va a tener el payload

Crear una carpeta llamda interfaces dentro de auth

crear un archivo llamado jwt-payload.interface.ts



export interface JwtPayload {

    email:string;

    // TODO: añadir todo lo que tengamos

}


- Agregar el configService dentro del auth module

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { User } from './entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';


@Module({
  controllers: [AuthController],
  providers: [AuthService],
  imports:[

    ConfigModule,

    TypeOrmModule.forFeature([User]),

    PassportModule.register({ defaultStrategy: 'jwt'}),


    // Modulo asyncrono agregando el ConfigService para obtener la variable de entorno
    JwtModule.registerAsync({
      imports:[ConfigModule],
      inject:[ConfigService],
      useFactory: (configService: ConfigService) => {
        //console.log('JWT_SECRET =>',  configService.get('JWT_SECRET') )

        return {
          secret: configService.get('JWT_SECRET') ,
          signOptions:{
            expiresIn: '2h'
          }
        }
      }

    })

    // Modulo asyncrono
    // JwtModule.registerAsync({
    //   imports:[],
    //   inject:[],
    //   useFactory: () => {
    //     console.log('JWT_SECRET =>',  process.env.JWT_SECRET)

    //     return {
    //       secret: process.env.JWT_SECRET,
    //       signOptions:{
    //         expiresIn: '2h'
    //       }
    //     }
    //   }

    // })

    // JwtModule.register({
    //   secret: process.env.JWT_SECRET,
    //   signOptions: {
    //     expiresIn: '2h'
    //   }

    // })
  ],
  exports:[
    TypeOrmModule
  ]
})
export class AuthModule {}





- Crear un archivo llamada 

jwt-strategy.ts

import { PassportStrategy } from "@nestjs/passport";
import { ExtractJwt, Strategy } from "passport-jwt";
import { User } from "../entities/user.entity";
import { JwtPayload } from "../interfaces/jwt-payload.interface";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";
import { Injectable, UnauthorizedException } from "@nestjs/common";

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy){

//Inyectamos el patron repositorio de usuario y el configService para obtener variables de entorno
 constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    configService: ConfigService    
 ){
    super({
        secretOrkey: configService.get('JWT_SECRET'),
        jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // Esta es la autenticacion que escogeremos en postman etc
    })
 }



   // Este metodo nos ayudara a validar si el usuario existe
   async validate(payload: JwtPayload): Promise<User>{

    // Destructuramos el payload
    const {email} = payload; 

    /// Buscamos el usuario por el email
    const user = await this.userRepository.findOneBy({email});


    // Validamos si el usuario existe
    if (!user)
        throw new UnauthorizedException('Token not valid');

    // Validamos si esta activo    
    if (!user.isActive)
        throw new UnauthorizedException('User is inactive, talk with an admin');


    //Retornamos el usuario
    return user;

   }



}

- Inyectamos la estrategia en el auth module

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { User } from './entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { JwtStrategy } from './strategies/jwt-strategy';


@Module({
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  imports:[

    ConfigModule,

    TypeOrmModule.forFeature([User]),

    PassportModule.register({ defaultStrategy: 'jwt'}),


    // Modulo asyncrono agregando el ConfigService para obtener la variable de entorno
    JwtModule.registerAsync({
      imports:[ConfigModule],
      inject:[ConfigService],
      useFactory: (configService: ConfigService) => {
        //console.log('JWT_SECRET =>',  configService.get('JWT_SECRET') )

        return {
          secret: configService.get('JWT_SECRET') ,
          signOptions:{
            expiresIn: '2h'
          }
        }
      }

    })

    // Modulo asyncrono
    // JwtModule.registerAsync({
    //   imports:[],
    //   inject:[],
    //   useFactory: () => {
    //     console.log('JWT_SECRET =>',  process.env.JWT_SECRET)

    //     return {
    //       secret: process.env.JWT_SECRET,
    //       signOptions:{
    //         expiresIn: '2h'
    //       }
    //     }
    //   }

    // })

    // JwtModule.register({
    //   secret: process.env.JWT_SECRET,
    //   signOptions: {
    //     expiresIn: '2h'
    //   }

    // })
  ],
  exports:[
    TypeOrmModule,
    JwtStrategy,
    PassportModule,
    JwtModule
  ]
})
export class AuthModule {}


** Generar un JWT

- Creamos una funcion para obtener el token desde el servicio de autorizacion

  // Funcion para obtener el token
  private getJwtToken(payload: JwtPayload) {
    // Generar el token
    const token = this.jwtService.sign(payload);

    return token;
  }

- Retornamos el token cuando se logeen o se cree un usuario

import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  UnauthorizedException,
} from '@nestjs/common';
import { CreateUserDto, LoginUserDto } from './dto/index';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { InjectRepository } from '@nestjs/typeorm';
import * as bcrypt from 'bcrypt';
import { JwtPayload } from './interfaces/jwt-payload.interface';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    private readonly jwtService: JwtService,
  ) {}

  async create(createAuthDto: CreateUserDto) {
    try {
      /// Destructuramos el objeto para separar  la contraseña
      const { password, ...userData } = createAuthDto;

      // Utilizamos el hasSync
      const user = this.userRepository.create({
        ...userData,
        password: bcrypt.hashSync(password, 10),
      });
      await this.userRepository.save(user);

      // Eliminamos la propiedad de password del objeto para no mostrarla
      delete user.password;

      return {
        ...user,
      token: this.getJwtToken({email: user.email})
    };
    } catch (error) {
      this.handleDBErrors(error);
    }
  }

  async login(loginUserDto: LoginUserDto) {
    //Destrucutrar el objeto que recibimos
    const { password, email } = loginUserDto;

    // Consultar el usuario que encuentre con el email

    // const user = await this.userRepository.findOneBy({ email });

    // otra manera de consultar
    const user = await this.userRepository.findOne({
      where: { email },
      select: { email: true, password: true },
    });

    // Validar el email
    if (!user)
      throw new UnauthorizedException('Credentials are not valid (email)');

    // Validar la contraseña
    if (!bcrypt.compareSync(password, user.password))
      throw new UnauthorizedException('Credentials are not valid (password)');
    // try {

    // } catch (error) {
    //   this.handleDBErrors(error)
    // }

    //Retornar el usuario
    return {
      ...user,
    token: this.getJwtToken({email: user.email})
  };
  }

  // Funcion para obtener el token
  private getJwtToken(payload: JwtPayload) {
    // Generar el token
    const token = this.jwtService.sign(payload);

    return token;
  }

  private handleDBErrors(error: any) {
    if (error.code === '23505') throw new BadRequestException(error.detail);

    console.log(error);

    throw new InternalServerErrorException('Please check server logs');
  }
}


- Podemos probar pegando el token dentro en la oagina y observaremos que
contiene el email del usuario

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImdiZXRpbkBtdXNpY3MuY29tIiwiaWF0IjoxNjkwNDE5OTk0LCJleHAiOjE2OTA0MjcxOTR9.DApRY-NgYCPbgiGv2VdpEzc5y92SGCavr5glMgmmnzI



- Agregamos un BEfore en la entidad para, colocar todos los email en miniscula de la base de datos

import { BeforeInsert, BeforeUpdate, Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text', {
    unique: true,
  })
  email: string;

  @Column('text',{
    select: false
  })
  password: string;

  @Column('text')
  fullName: string;

  @Column('bool', {
    default: true,
  })
  isActive: boolean;

  @Column('text', {
    array: true,
    default: ['user'],
  })
  roles: string[];


  @BeforeInsert()
  checkFieldsBeforeInsert(){
    this.email = this.email.toLocaleLowerCase().trim();
  }


  @BeforeUpdate()
  checkFieldsBeforeUpdate(){
    this.checkFieldsBeforeInsert();
  }
}


** Private Route  - General

- Crear una ruta Get en el controlador de Auth

  @Get('private')
  testingPrivateRoute(){
    return {
      ok: true,
      message: 'Hola Mundo'
    }
  }

- Agregar un Guards para proteger la ruta

import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto ,LoginUserDto} from './dto/index';
import { AuthGuard } from '@nestjs/passport';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  create(@Body() createAuthDto: CreateUserDto) {
    return this.authService.create(createAuthDto);
  }


  @Post('login')
  loginUser(@Body() loginUserDto: LoginUserDto) {
    return this.authService.login(loginUserDto);
  }


  @Get('private')
  @UseGuards(AuthGuard())
  testingPrivateRoute(){
    return {
      ok: true,
      message: 'Hola Mundo'
    }
  }

}


Si probamos la ruta me indica que no no estoy autorizado

http://localhost:3000/api/auth/private

-  Si pegamos el token en postman o insomnia ,  nos va a permitr  ver la peticion


eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImdiZXRpbkBtdXNpY3MuY29tIiwiaWF0IjoxNjkwNDE5OTk0LCJleHAiOjE2OTA0MjcxOTR9.DApRY-NgYCPbgiGv2VdpEzc5y92SGCavr5glMgmmnzI



