** Crear la entidad de usuario


- Crear un nuevo recurso

nest g res auth --no-spec


- Creamos la entidad

import { Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  email: string;

  pasword: string;

  fullName: string;

  isActive: boolean;

  roles: string[];
}

- Importamos la entidad en el modulo para que se cree la tabla

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { User } from './entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';


@Module({
  controllers: [AuthController],
  providers: [AuthService],
  imports:[
    TypeOrmModule.forFeature([User])
  ],
  exports:[
    TypeOrmModule
  ]
})
export class AuthModule {}


- Terminamos de configurar las demas columnas de la entidad

import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text', {
    unique: true,
  })
  email: string;

  @Column('text')
  password: string;

  @Column('text')
  fullName: string;

  @Column('bool', {
    default: true,
  })
  isActive: boolean;

  @Column('text', {
    array: true,
    default: ['user'],
  })
  roles: string[];
}



** Crear usuario

- Crear el DTO para el usuario

create-user.dto.ts



Expression regular para la contraseña
https://gist.github.com/Klerith/c77edd9d86174aa68efbfddd21f053a2


import {
  IsEmail,
  IsString,
  Matches,
  MaxLength,
  MinLength,
} from 'class-validator';

export class CreateUserDto {
  @IsString()
  @IsEmail()
  email: string;

  // Agregar expresion regular para la contraseña
  @IsString()
  @MinLength(6)
  @MaxLength(50)
  @Matches(/(?:(?=.*\d)|(?=.*\W+))(?![.\n])(?=.*[A-Z])(?=.*[a-z]).*$/, {
    message:
      'The password must have a Uppercase, lowercase letter and a number',
  })
  password: string;

  @IsString()
  @MinLength(1)
  fullName: string;
}



- Importamos el DTO en el controlador para crear el usuario

import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto } from './dto/create-user.dto';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  create(@Body() createAuthDto: CreateUserDto) {
    return this.authService.create(createAuthDto);
  }
}


- Agregamos la funcion en el servicio

import { Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';


@Injectable()
export class AuthService {
  create(createAuthDto: CreateUserDto) {
    return 'This action adds a new auth';
  }

 
}


Probar en Insomnia, sin body para identificar que si esta validando el dto y con
body para ver que se ejecuta la funcion

{
	"email":"gbetin@music.com",
	"password": "Abc123",
	"fullName": "Gabriel Betin"
}


- Vamos a crear el usuario desde el servicio y creamos la funcion para el error

import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { InjectRepository } from '@nestjs/typeorm';

@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  async create(createAuthDto: CreateUserDto) {
    try {
      const user = this.userRepository.create(createAuthDto);
      await this.userRepository.save(user);
      return user;
    } catch (error) {
      this.handleDBErrors(error);
    }
  }

  private handleDBErrors(error: any) {
    if (error.code === '23505') throw new BadRequestException(error.detail);

    console.log(error);

    throw new InternalServerErrorException('Please check server logs');
  }
}


** Modulos Asyncronos

- Importamos el modulo de JWT de forma asyncrona en el auth module


    // Modulo asyncrono
    JwtModule.registerAsync({
      imports:[],
      inject:[],
      useFactory: () => {
        console.log('JWT_SECRET =>',  process.env.JWT_SECRET)

        return {
          secret: process.env.JWT_SECRET,
          signOptions:{
            expiresIn: '2h'
          }
        }
      }

    })

- De esta manera tambien se puede agregar el modulo, con el configservice

    // Modulo asyncrono agregando el ConfigService para obtener la variable de entorno
    JwtModule.registerAsync({
      imports:[ConfigModule],
      inject:[ConfigService],
      useFactory: (configService: ConfigService) => {
        console.log('JWT_SECRET =>',  configService.get('JWT_SECRET') )

        return {
          secret: configService.get('JWT_SECRET') ,
          signOptions:{
            expiresIn: '2h'
          }
        }
      }

    })

De esta manera ya tenemos la firma que va a tener nuestrosd JWT

** JwtStrategy

https://jwt.io/

- Crear una carpeta llamada strategies dentro de auth

- Crear la interface que va a tener el payload

Crear una carpeta llamda interfaces dentro de auth

crear un archivo llamado jwt-payload.interface.ts



export interface JwtPayload {

    email:string;

    // TODO: añadir todo lo que tengamos

}


- Agregar el configService dentro del auth module

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { User } from './entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';


@Module({
  controllers: [AuthController],
  providers: [AuthService],
  imports:[

    ConfigModule,

    TypeOrmModule.forFeature([User]),

    PassportModule.register({ defaultStrategy: 'jwt'}),


    // Modulo asyncrono agregando el ConfigService para obtener la variable de entorno
    JwtModule.registerAsync({
      imports:[ConfigModule],
      inject:[ConfigService],
      useFactory: (configService: ConfigService) => {
        //console.log('JWT_SECRET =>',  configService.get('JWT_SECRET') )

        return {
          secret: configService.get('JWT_SECRET') ,
          signOptions:{
            expiresIn: '2h'
          }
        }
      }

    })

    // Modulo asyncrono
    // JwtModule.registerAsync({
    //   imports:[],
    //   inject:[],
    //   useFactory: () => {
    //     console.log('JWT_SECRET =>',  process.env.JWT_SECRET)

    //     return {
    //       secret: process.env.JWT_SECRET,
    //       signOptions:{
    //         expiresIn: '2h'
    //       }
    //     }
    //   }

    // })

    // JwtModule.register({
    //   secret: process.env.JWT_SECRET,
    //   signOptions: {
    //     expiresIn: '2h'
    //   }

    // })
  ],
  exports:[
    TypeOrmModule
  ]
})
export class AuthModule {}





- Crear un archivo llamada 

jwt-strategy.ts

import { PassportStrategy } from "@nestjs/passport";
import { ExtractJwt, Strategy } from "passport-jwt";
import { User } from "../entities/user.entity";
import { JwtPayload } from "../interfaces/jwt-payload.interface";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";
import { Injectable, UnauthorizedException } from "@nestjs/common";

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy){

//Inyectamos el patron repositorio de usuario y el configService para obtener variables de entorno
 constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    configService: ConfigService    
 ){
    super({
        secretOrkey: configService.get('JWT_SECRET'),
        jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // Esta es la autenticacion que escogeremos en postman etc
    })
 }



   // Este metodo nos ayudara a validar si el usuario existe
   async validate(payload: JwtPayload): Promise<User>{

    // Destructuramos el payload
    const {email} = payload; 

    /// Buscamos el usuario por el email
    const user = await this.userRepository.findOneBy({email});


    // Validamos si el usuario existe
    if (!user)
        throw new UnauthorizedException('Token not valid');

    // Validamos si esta activo    
    if (!user.isActive)
        throw new UnauthorizedException('User is inactive, talk with an admin');


    //Retornamos el usuario
    return user;

   }



}

- Inyectamos la estrategia en el auth module

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { User } from './entities/user.entity';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { JwtStrategy } from './strategies/jwt-strategy';


@Module({
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  imports:[

    ConfigModule,

    TypeOrmModule.forFeature([User]),

    PassportModule.register({ defaultStrategy: 'jwt'}),


    // Modulo asyncrono agregando el ConfigService para obtener la variable de entorno
    JwtModule.registerAsync({
      imports:[ConfigModule],
      inject:[ConfigService],
      useFactory: (configService: ConfigService) => {
        //console.log('JWT_SECRET =>',  configService.get('JWT_SECRET') )

        return {
          secret: configService.get('JWT_SECRET') ,
          signOptions:{
            expiresIn: '2h'
          }
        }
      }

    })

    // Modulo asyncrono
    // JwtModule.registerAsync({
    //   imports:[],
    //   inject:[],
    //   useFactory: () => {
    //     console.log('JWT_SECRET =>',  process.env.JWT_SECRET)

    //     return {
    //       secret: process.env.JWT_SECRET,
    //       signOptions:{
    //         expiresIn: '2h'
    //       }
    //     }
    //   }

    // })

    // JwtModule.register({
    //   secret: process.env.JWT_SECRET,
    //   signOptions: {
    //     expiresIn: '2h'
    //   }

    // })
  ],
  exports:[
    TypeOrmModule,
    JwtStrategy,
    PassportModule,
    JwtModule
  ]
})
export class AuthModule {}


** Generar un JWT

- Creamos una funcion para obtener el token desde el servicio de autorizacion

  // Funcion para obtener el token
  private getJwtToken(payload: JwtPayload) {
    // Generar el token
    const token = this.jwtService.sign(payload);

    return token;
  }

- Retornamos el token cuando se logeen o se cree un usuario

import {
  BadRequestException,
  Injectable,
  InternalServerErrorException,
  UnauthorizedException,
} from '@nestjs/common';
import { CreateUserDto, LoginUserDto } from './dto/index';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { InjectRepository } from '@nestjs/typeorm';
import * as bcrypt from 'bcrypt';
import { JwtPayload } from './interfaces/jwt-payload.interface';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    private readonly jwtService: JwtService,
  ) {}

  async create(createAuthDto: CreateUserDto) {
    try {
      /// Destructuramos el objeto para separar  la contraseña
      const { password, ...userData } = createAuthDto;

      // Utilizamos el hasSync
      const user = this.userRepository.create({
        ...userData,
        password: bcrypt.hashSync(password, 10),
      });
      await this.userRepository.save(user);

      // Eliminamos la propiedad de password del objeto para no mostrarla
      delete user.password;

      return {
        ...user,
      token: this.getJwtToken({email: user.email})
    };
    } catch (error) {
      this.handleDBErrors(error);
    }
  }

  async login(loginUserDto: LoginUserDto) {
    //Destrucutrar el objeto que recibimos
    const { password, email } = loginUserDto;

    // Consultar el usuario que encuentre con el email

    // const user = await this.userRepository.findOneBy({ email });

    // otra manera de consultar
    const user = await this.userRepository.findOne({
      where: { email },
      select: { email: true, password: true },
    });

    // Validar el email
    if (!user)
      throw new UnauthorizedException('Credentials are not valid (email)');

    // Validar la contraseña
    if (!bcrypt.compareSync(password, user.password))
      throw new UnauthorizedException('Credentials are not valid (password)');
    // try {

    // } catch (error) {
    //   this.handleDBErrors(error)
    // }

    //Retornar el usuario
    return {
      ...user,
    token: this.getJwtToken({email: user.email})
  };
  }

  // Funcion para obtener el token
  private getJwtToken(payload: JwtPayload) {
    // Generar el token
    const token = this.jwtService.sign(payload);

    return token;
  }

  private handleDBErrors(error: any) {
    if (error.code === '23505') throw new BadRequestException(error.detail);

    console.log(error);

    throw new InternalServerErrorException('Please check server logs');
  }
}


- Podemos probar pegando el token dentro en la oagina y observaremos que
contiene el email del usuario

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImdiZXRpbkBtdXNpY3MuY29tIiwiaWF0IjoxNjkwNDE5OTk0LCJleHAiOjE2OTA0MjcxOTR9.DApRY-NgYCPbgiGv2VdpEzc5y92SGCavr5glMgmmnzI



- Agregamos un BEfore en la entidad para, colocar todos los email en miniscula de la base de datos

import { BeforeInsert, BeforeUpdate, Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text', {
    unique: true,
  })
  email: string;

  @Column('text',{
    select: false
  })
  password: string;

  @Column('text')
  fullName: string;

  @Column('bool', {
    default: true,
  })
  isActive: boolean;

  @Column('text', {
    array: true,
    default: ['user'],
  })
  roles: string[];


  @BeforeInsert()
  checkFieldsBeforeInsert(){
    this.email = this.email.toLocaleLowerCase().trim();
  }


  @BeforeUpdate()
  checkFieldsBeforeUpdate(){
    this.checkFieldsBeforeInsert();
  }
}


** Private Route  - General

- Crear una ruta Get en el controlador de Auth

  @Get('private')
  testingPrivateRoute(){
    return {
      ok: true,
      message: 'Hola Mundo'
    }
  }

- Agregar un Guards para proteger la ruta

import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto ,LoginUserDto} from './dto/index';
import { AuthGuard } from '@nestjs/passport';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  create(@Body() createAuthDto: CreateUserDto) {
    return this.authService.create(createAuthDto);
  }


  @Post('login')
  loginUser(@Body() loginUserDto: LoginUserDto) {
    return this.authService.login(loginUserDto);
  }


  @Get('private')
  @UseGuards(AuthGuard())
  testingPrivateRoute(){
    return {
      ok: true,
      message: 'Hola Mundo'
    }
  }

}


Si probamos la ruta me indica que no no estoy autorizado

http://localhost:3000/api/auth/private

-  Si pegamos el token en postman o insomnia ,  nos va a permitr  ver la peticion


eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImdiZXRpbkBtdXNpY3MuY29tIiwiaWF0IjoxNjkwNDE5OTk0LCJleHAiOjE2OTA0MjcxOTR9.DApRY-NgYCPbgiGv2VdpEzc5y92SGCavr5glMgmmnzI

** Cambiar email por id

- Cambiar el nombre en la interface



export interface JwtPayload {

    id:string;

    // TODO: añadir todo lo que tengamos

}

- Cambiar el parametro a enviar en el servicio de auth 

  token: this.getJwtToken({id: user.id})

- Cambiarlo en la estrategia

import { PassportStrategy } from "@nestjs/passport";
import { ExtractJwt, Strategy } from "passport-jwt";
import { User } from "../entities/user.entity";
import { JwtPayload } from "../interfaces/jwt-payload.interface";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { ConfigService } from "@nestjs/config";
import { Injectable, UnauthorizedException } from "@nestjs/common";

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy){

//Inyectamos el patron repositorio de usuario y el configService para obtener variables de entorno
 constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    configService: ConfigService    
 ){
    super({
        secretOrKey:  configService.get('JWT_SECRET'),
        jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // Esta es la autenticacion que escogeremos en postman etc
    })
 }



   // Este metodo nos ayudara a validar si el usuario existe
   async validate(payload: JwtPayload): Promise<User>{

    // Destructuramos el payload
    const {id} = payload; 

    /// Buscamos el usuario por el email
    const user = await this.userRepository.findOneBy({id});


    // Validamos si el usuario existe
    if (!user)
        throw new UnauthorizedException('Token not valid');

    // Validamos si esta activo    
    if (!user.isActive)
        throw new UnauthorizedException('User is inactive, talk with an admin');


    //Retornamos el usuario
    return user;

   }



}

- Agregar en el where el id

  async login(loginUserDto: LoginUserDto) {
    //Destrucutrar el objeto que recibimos
    const { password, email } = loginUserDto;

    // Consultar el usuario que encuentre con el email

    // const user = await this.userRepository.findOneBy({ email });

    // otra manera de consultar
    const user = await this.userRepository.findOne({
      where: { email },
      select: { email: true, password: true, id:true },
    });

    // Validar el email
    if (!user)
      throw new UnauthorizedException('Credentials are not valid (email)');

    // Validar la contraseña
    if (!bcrypt.compareSync(password, user.password))
      throw new UnauthorizedException('Credentials are not valid (password)');
    // try {

    // } catch (error) {
    //   this.handleDBErrors(error)
    // }

    //Retornar el usuario
    return {
      ...user,
      token: this.getJwtToken({id: user.id})
  };
  }

** Custom Property Decorator

- De esta manera podriamos obtener el usuario de la request

 @Get('private')
  @UseGuards(AuthGuard())
  testingPrivateRoute(
    @Req() request :Express.Request
  ){

    console.log({user: request.user})
    return {
      ok: true,
      message: 'Hola Mundo'
    }
  }

- Pero mejor lo obtenenemos realizando un decorador personalizado

Creamos una carpeta llamada decorators dentro de auth

Dentro de la carpeta, este archivo => get-user.decorator.ts

import { ExecutionContext, InternalServerErrorException, createParamDecorator } from "@nestjs/common";



export const GetUser = createParamDecorator(
    (data, ctx: ExecutionContext) => {
     
        // Obtenemos la reques desde el contexto
        const req = ctx.switchToHttp().getRequest();
        
        // Almacenamos el usuario enun a variable
        const user = req.user;

        if(!user)
            throw new InternalServerErrorException('User not found (request)');

        return user
    }

);

- Agregamos el decorador en el controlador

import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Req,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto ,LoginUserDto} from './dto/index';
import { AuthGuard } from '@nestjs/passport';
import * as request from 'supertest';
import { GetUser } from './decorators/get-user.decorator';
import { User } from './entities/user.entity';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  create(@Body() createAuthDto: CreateUserDto) {
    return this.authService.create(createAuthDto);
  }


  @Post('login')
  loginUser(@Body() loginUserDto: LoginUserDto) {
    return this.authService.login(loginUserDto);
  }


  @Get('private')
  @UseGuards(AuthGuard())
  testingPrivateRoute(
    //@Req() request :Express.Request

    // Obtenedremos el usuario
    @GetUser() user: User
    ){

   // console.log({user: request.user})
    return {
      ok: true,
      user
    }
  }

}


** Utilizar de dos maneras el decorador

- Lo agregamos en el controlador

 @Get('private')
  @UseGuards(AuthGuard())
  testingPrivateRoute(
    //@Req() request :Express.Request

    // Obtenedremos el usuario
    @GetUser() user: User,
    @GetUser('email') userEmail: string
    ){

   // console.log({user: request.user})
    return {
      ok: true,
      user,

      userEmail
    }
  }

- Regresamos  con un operador ternario el usuario , ya sea con data o sin data

import { ExecutionContext, InternalServerErrorException, createParamDecorator } from "@nestjs/common";



export const GetUser = createParamDecorator(
    (data: string, ctx: ExecutionContext) => {
     
        // Obtenemos la reques desde el contexto
        const req = ctx.switchToHttp().getRequest();
        
        // Almacenamos el usuario enun a variable
        const user = req.user;

        if(!user)
            throw new InternalServerErrorException('User not found (request)');

        // Agregamos un ternario para que si tiene data retorne el arreglo de objetos    
        return (!data)
              ? user
              : user[data]
    }

);


- Crear otro custom decorator que muestre los headers recibido

Crear el archivo raw-headers.decorator.ts

import { ExecutionContext, InternalServerErrorException, createParamDecorator } from "@nestjs/common";



export const RawHeaders = createParamDecorator(
    (data: string, ctx: ExecutionContext) => {
     
        // Obtenemos la reques desde el contexto
        const req = ctx.switchToHttp().getRequest();
        
       
        return req.rawHeaders;
    }

);

- creamos un archivo de barril para exportar los dos decoradores

index.ts

export { GetUser } from "./get-user.decorator";
export { RawHeaders } from "./raw-headers.decorator";


- Cambiamos la importacion en el controlador

import { GetUser,RawHeaders } from './decorators';

- Agregamos el nuevo dcorador en la ruta del controlador


import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Req,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto ,LoginUserDto} from './dto/index';
import { AuthGuard } from '@nestjs/passport';
import * as request from 'supertest';
import { GetUser,RawHeaders } from './decorators';
import { User } from './entities/user.entity';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  create(@Body() createAuthDto: CreateUserDto) {
    return this.authService.create(createAuthDto);
  }


  @Post('login')
  loginUser(@Body() loginUserDto: LoginUserDto) {
    return this.authService.login(loginUserDto);
  }


  @Get('private')
  @UseGuards(AuthGuard())
  testingPrivateRoute(
    //@Req() request :Express.Request

    // Obtenedremos el usuario
    @GetUser() user: User,
    @GetUser('email') userEmail: string,
    @RawHeaders() rawHeaders: string[]
    ){

   // console.log({user: request.user})
    return {
      ok: true,
      user,
      userEmail,
      rawHeaders

    }
  }

}


-De todas maneras ya existe un decorador que trae los headers

@Headers


import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Req,
  Headers,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { CreateUserDto ,LoginUserDto} from './dto/index';
import { AuthGuard } from '@nestjs/passport';
import * as request from 'supertest';
import { GetUser,RawHeaders } from './decorators';
import { User } from './entities/user.entity';
import { IncomingHttpHeaders } from 'http';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  create(@Body() createAuthDto: CreateUserDto) {
    return this.authService.create(createAuthDto);
  }


  @Post('login')
  loginUser(@Body() loginUserDto: LoginUserDto) {
    return this.authService.login(loginUserDto);
  }


  @Get('private')
  @UseGuards(AuthGuard())
  testingPrivateRoute(
    //@Req() request :Express.Request

    // Obtenedremos el usuario
    @GetUser() user: User,
    @GetUser('email') userEmail: string,
    @RawHeaders() rawHeaders: string[],
    @Headers() headers: IncomingHttpHeaders
    ){

   // console.log({user: request.user})
    return {
      ok: true,
      user,
      userEmail,
      rawHeaders,
      headers

    }
  }

}



** Custom Guard y Custom Decorator

 - Crear un nuevo end POint para obtener el usuario

  @Get('private2')
  @UseGuards(AuthGuard())
  privateRoute2(
    
    @GetUser() user: User
  ){

    return {
      ok: true,
      user
    }

  }



- Agregamos una metadata


  @Get('private2')
  @SetMetadata('roles', ['admin','super-user','']) // En esta metada tenemos un arreglo de roles
  @UseGuards(AuthGuard())
  privateRoute2(
    
    @GetUser() user: User
  ){

    return {
      ok: true,
      user
    }

  }

- Creamos un guard pra validar los roles

nest g gu auth/guards/userRoles --no-spec

import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class UserRolesGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {


    console.log('UserRoleGuard')

    return true;
  }
}

- probar el guards


  @Get('private2')
  @SetMetadata('roles', ['admin','super-user','']) // En esta metada tenemos un arreglo de roles
  @UseGuards(AuthGuard(), UserRolesGuard)
  privateRoute2(
    
    @GetUser() user: User
  ){

    return {
      ok: true,
      user
    }

  }

}

- Agregamos al guards un reflector para obtener los datos de la metada


import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';

@Injectable()
export class UserRolesGuard implements CanActivate {

  constructor(
    // ME ayuda a aver iformacion de los decoradores y metadada
    private readonly reflector: Reflector
  ){

  }


  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {


    //console.log('UserRoleGuard')


    // Obtenemos el arreglo de roles del metadata
    const validRoles: string[] = this.reflector.get('roles', context.getHandler())

    console.log(validRoles)

    return true;
  }
}

** Verificar el rol del usuario

Agregamos estas validaciones para que elk guards valide 

import {
  BadRequestException,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
  Injectable,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { User } from 'src/auth/entities/user.entity';

@Injectable()
export class UserRolesGuard implements CanActivate {
  constructor(
    // ME ayuda a aver iformacion de los decoradores y metadada
    private readonly reflector: Reflector,
  ) {}

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    //console.log('UserRoleGuard')

    // Obtenemos el arreglo de roles del metadata
    const validRoles: string[] = this.reflector.get(
      'roles',
      context.getHandler(),
    );

    // Obtenemos el usuario
    const req = context.switchToHttp().getRequest();
    const user = req.user as User;

    // Validamos si el usuario no exista
    if (!user) throw new BadRequestException('User not found');

    // asi obtenemos el rol del usuario
    console.log({ userRoles: user.roles });

    //console.log(validRoles)

    // Recorremos el arreglo de usuario
    for (const role of user.roles) {
      // Si al menos hay un role dentro del arreglo retornamos true
      if (validRoles.includes(role)) {
        return true;
      }
    }

    // Si no esta en el arreglo retornamos la exception, informando 
    // los tipos de usuarios que debe tener
    throw new ForbiddenException(
      `User ${user.fullName} need a valid role: [${validRoles}]`
    )

    //return true;
  }
}

- Agregamos una validacion para el caso en el que no se ennvie roles en el metada,
se dejhe pasar

  // Si  no hay metadata de arreglos, se retorna true  
    if(!validRoles) return true;
    if(validRoles.length === 0) return true;


** Custom Decorator

- Crear un un decorator llamado  roleProtected

nest g d auth/decorators/roleprotected --no-spec

import { SetMetadata } from '@nestjs/common';

export const Roleprotected = (...args: string[]) => SetMetadata('roleprotected', args);


-   Agregamos una constante que se llame META_ROLES, para almacenar el 
string de la metadata y asi nos facilita cambiar en un solo lado

import { SetMetadata } from '@nestjs/common';

export const META_ROLES = 'roles';


export const Roleprotected = (...args: string[]) => {

return SetMetadata(META_ROLES, args);

};


- Agregamos la metada en el guard de user-roles

import {
  BadRequestException,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
  Injectable,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { META_ROLES } from 'src/auth/decorators/roleprotected.decorator';
import { User } from 'src/auth/entities/user.entity';

@Injectable()
export class UserRolesGuard implements CanActivate {
  constructor(
    // ME ayuda a aver iformacion de los decoradores y metadada
    private readonly reflector: Reflector,
  ) {}

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    //console.log('UserRoleGuard')

    // Obtenemos el arreglo de roles del metadata
    const validRoles: string[] = this.reflector.get(
      META_ROLES,
      context.getHandler(),
    );

    // Si  no hay metadata de arreglos, se retorna true  
    if(!validRoles) return true;
    if(validRoles.length === 0) return true;

    // Obtenemos el usuario
    const req = context.switchToHttp().getRequest();
    const user = req.user as User;

    // Validamos si el usuario no exista
    if (!user) throw new BadRequestException('User not found');

    // asi obtenemos el rol del usuario
    console.log({ userRoles: user.roles });

    //console.log(validRoles)

    // Recorremos el arreglo de usuario
    for (const role of user.roles) {
      // Si al menos hay un role dentro del arreglo retornamos true
      if (validRoles.includes(role)) {
        return true;
      }
    }

    // Si no esta en el arreglo retornamos la exception, informando 
    // los tipos de usuarios que debe tener
    throw new ForbiddenException(
      `User ${user.fullName} need a valid role: [${validRoles}]`
    )

    //return true;
  }
}


- Creamos una interface que tenga un enum con los tipos de roles

export enum ValidRoles {
  admin = 'admin',
  superUser = 'super-user',
  user = 'user',
}


- Creamos el archivo de barril para exportar las interfaces

index.ts

export { JwtPayload } from './jwt-payload.interface';
export { ValidRoles } from "./valid-roles";



- Agregamos el tipo al decorador de role protected

import { SetMetadata } from '@nestjs/common';
import { ValidRoles } from '../interfaces';

export const META_ROLES = 'roles';


export const Roleprotected = (...args: ValidRoles[]) => {

return SetMetadata(META_ROLES, args);

};


- Agregamos el decorador en la ruta 


  @Get('private2')
  //@SetMetadata('roles', ['admin','super-user','']) // En esta metada tenemos un arreglo de roles
  @Roleprotected(ValidRoles.superUser, ValidRoles.admin)
  @UseGuards(AuthGuard(), UserRolesGuard)
  privateRoute2(
    
    @GetUser() user: User
  ){

    return {
      ok: true,
      user
    }

  }

** Composicion de decoradores

https://docs.nestjs.com/custom-decorators#decorator-composition

- Creamosun decorador de acuerdo a la documentacion =>auth.decorator.ts

Es un decorador que va a tener por dentro otros decoradores

- Copiamos el codigo de la documentacion

import { applyDecorators } from '@nestjs/common';

export function Auth(...roles: Role[]) {
  return applyDecorators(
    SetMetadata('roles', roles),
    UseGuards(AuthGuard, RolesGuard),
    ApiBearerAuth(),
    ApiUnauthorizedResponse({ description: 'Unauthorized' }),
  );
}


- Modificamos la funcion 
import { UseGuards, applyDecorators } from '@nestjs/common';
import { ValidRoles } from '../interfaces';
import { Roleprotected } from './roleprotected.decorator';
import { AuthGuard } from '@nestjs/passport';
import { UserRolesGuard } from '../guards/user-roles/user-roles.guard';

export function Auth(...roles: ValidRoles[]) {
  return applyDecorators(
    Roleprotected(...roles),
    UseGuards(AuthGuard(), UserRolesGuard),

  );
}

- Exportamos el decorador en el archivo de barril

export { Auth } from "./auth.decorator";
export { Roleprotected } from "./roleprotected.decorator";

export { GetUser } from "./get-user.decorator";
export { RawHeaders } from "./raw-headers.decorator";


- Agregamos  el decoador en la ruta

  @Get('private3')
  //@SetMetadata('roles', ['admin','super-user','']) // En esta metada tenemos un arreglo de roles
  //@Roleprotected(ValidRoles.superUser, ValidRoles.admin)
  //@UseGuards(AuthGuard(), UserRolesGuard)
  @Auth()
  privateRoute3(
    
    @GetUser() user: User
  ){

    return {
      ok: true,
      user
    }

  }

}


** 
 





